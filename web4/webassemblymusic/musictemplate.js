export function wrapJSmusicInTemplate(jsmusic) {
    return `
    (function () {
        'use strict';
    
        const t = new Array(128).fill(null).map(((t, e) => ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"][e % 12] + "" + Math.floor(e / 12))).reduce(((t, e, n) => (t[e] = n, t)), {}); let e = 0; function n() { return e } let s = n(), a = 110; const o = () => (n() - s) / 6e4 * a; let i = []; function c(t) { return new Promise((e => i.push({ targetTime: Math.round(n() + t), resolve: e }))) } function r() { e = 0; } async function u() { const t = i.reduce(((t, e) => e.targetTime < t || -1 === t ? e.targetTime : t), -1), n = []; i.filter((e => e.targetTime === t)).forEach((t => n.push(t.resolve()))), i = i.filter((t => t.targetTime > e)), e = t, await Promise.all(n); } const h = new Array(128).fill(null).map(((t, e) => ["c", "cs", "d", "ds", "e", "f", "fs", "g", "gs", "a", "as", "b"][e % 12] + "" + Math.floor(e / 12))); Array.prototype.quantize = function (t, e = 1) { return function (t, e, n = 1) { return t.map((t => { const s = t[0] * e; return [(s - (s - Math.round(s)) * n) / e, t[1]] })) }(this, t, e) }, Array.prototype.fixVelocity = function (t) { return this.map((e => e.fixVelocity ? e.fixVelocity(t) : e)) }, Array.prototype.repeat = function (t = 1) { const e = this.slice(0); let n = this; for (let s = 0; s < t; s++)n = n.concat(e); return n }; class l extends class { constructor(t) { this.output = t, this.channel = 0, this.velocity = 100, this.offset = 0, this.stepsperbeat = 16; } setChannel(t) { this.channel = t; } async waitForStep(t) { return this.waitForBeat(t / this.stepsperbeat) } async waitForBeat(t) { let e = Math.floor((t + this.offset) / a * 6e4 - (n() - s)); return e < 0 ? void 0 : c(e) } toNoteNumber(e) { return t[e] } async waitDuration(t) { return c(60 * t * 1e3 / a) } async pitchbend(t, e, n, s) { const a = (e - t) / s; let o = t; for (let t = 0; t < s; t++) { const t = Math.round(o); this.output.sendMessage([224 + this.channel, 127 & t, (16256 & t) >> 7]), o += a, await this.waitDuration(n / s); } this.output.sendMessage([224 + this.channel, 127 & e, (16256 & e) >> 7]); } async controlchange(t, e, n, s, a) { const o = (n - e) / a; let i = e; for (let e = 0; e < a; e++) { const e = Math.round(i); this.output.sendMessage([176 + this.channel, t, e]), i += o, await this.waitDuration(s / a); } this.output.sendMessage([176 + this.channel, t, 127 & n]); } async note(t, e) { this.output.sendMessage([144 + this.channel, t, this.velocity]), await this.waitDuration(e), this.output.sendMessage([128 + this.channel, t, 0]); } async playNote(e, n) { this.output.sendMessage([144 + this.channel, t[e], this.velocity]), await this.waitDuration(n), this.output.sendMessage([128 + this.channel, t[e], 0]); } }{ constructor(t, e, n = 1, s = 100) { super(t), this.channel = e, this.stepsperbeat = n, this.defaultvelocity = s; } async steps(t, e) { this.offset = Math.round(o()); for (let n = 0; n < e.length; n++) { let s = n / t; const a = e[n]; if (a && a.constructor && "AsyncFunction" === a.constructor.name) a(this, s); else if (a && a.constructor && "Function" === a.constructor.name) (async () => { await this.waitForBeat(s), a(this, s); })(); else if (a && a.length) for (let t of a) "AsyncFunction" === t.constructor.name || await this.waitForBeat(s), t(this, s); } await this.waitForBeat(e.length / t); } async play(t, e) { this.offset = Math.round(o()); let n = 0; "function" == typeof t[0] && (t = [[0].concat(t)]); for (let s = 0; s < t.length; s++) { const a = t[s]; e || (n = a[0]); for (let t = 1; t < a.length; t++) { const e = a[t]; "AsyncFunction" === e.constructor.name ? e(this, n) : (async () => { const t = n; await this.waitForBeat(n), e(this, t); })(); } 1 === e && (n += a[0]); } await this.waitForBeat(n); } } let f = [], d = [], p = {}, y = {}, g = []; const m = {}; let w = [], M = {}; Object.getPrototypeOf((async function () { })).constructor; const F = { sendMessage: t => { const e = 15 & t[0]; (3 !== t.length || !p[e] && !Object.keys(y).length || y[e]) && f.push({ time: n(), message: t }); } }; const v = function () { const t = {}; return h.forEach(((e, n) => t[e] = (t, e, s) => { const a = (n, a = e) => async (e, o) => { await e.waitForBeat(o + (s || 0)), e.velocity = a && "object" != typeof t ? a : e.defaultvelocity, t && "object" != typeof t || (t = 1 / e.stepsperbeat), e.note(n, t); }, o = a(n); return "object" == typeof t ? o(t, e) : (o.transpose = t => a(n + t), o.fixVelocity = t => a(n, t), o) })), h.forEach(((e, n) => { t[e].transpose = e => t[h[n + e]], t[e].fixVelocity = e => t[h[n]](void 0, e); })), t }(), T = { output: F, setBPM: t => a = t, TrackerPattern: l, createTrack: (t, e, s) => { const a = new l({ startTime: n(), midievents: [], sendMessage: function (t) { this.midievents.push({ time: n() - this.startTime, message: t }), F.sendMessage(t); } }, t, e, s); return w.push(a), a }, playFromHere: function () { f = f.filter((t => 176 == (240 & t.message[0]))).map((t => Object.assign(t, { time: 0 }))), r(); }, loopHere: async function () { F.sendMessage([-1]); }, pitchbend: (t, e, n, s) => async (a, o) => { await a.waitForBeat(o), a.pitchbend(t, e, n, s); }, controlchange: (t, e, n, s, a) => async (o, i) => { await o.waitForBeat(i), o.controlchange(t, e, n || e, s, a); }, waitForBeat: async function (t) { let e = Math.floor(t / a * 6e4 - (n() - s)); return e < 0 && (e = 0), c(e) }, startRecording: function () { F.sendMessage([-2]); }, stopRecording: function () { F.sendMessage([-3]); }, startVideo: function (t, e = 0) { m[t].schedule.push({ startTime: n(), clipStartTime: e }); }, stopVideo: function (t) { m[t].schedule[m[t].schedule.length - 1].stopTime = n(); }, definePartStart: t => M[t] = { startTime: n() }, definePartEnd: t => M[t].endTime = n(), mute: t => p[t] = !0, solo: t => y[t] = !0, addInstrument: t => d.push(t), addAudio: async t => { await g.find((async e => (await e).url === t)) || g.push(new Promise((async (e, n) => { const s = { url: t }; try { const n = await fetch(t).then((t => t.arrayBuffer())).then((t => (new AudioContext).decodeAudioData(t))); s.leftbuffer = n.getChannelData(0).buffer, s.rightbuffer = n.getChannelData(1).buffer, console.log("loaded", t), e(s); } catch (t) { n(t); } }))); }, addVideo: async (t, e) => { if (!m[t]) { const n = document.createElement("video"); n.src = e, n.autoplay = !1, n.muted = !0, m[t] = { videoElement: n, schedule: [] }; } }, addImage: async (t, e) => { if (!m[t]) { const n = new Image; n.src = e, m[t] = { imageElement: n, schedule: [] }; } }, note: (t, e, n, s) => v[h[t]](e, n, s) }; Object.assign(T, v); const B = Object.keys(T); async function j(t) { f = [], d = [], w = [], Object.values(m).forEach((t => t.schedule = [])), p = {}, y = {}, M = {}, r(); let e, n = !0; for (t.apply(null, B.map((t => T[t]))).then((() => n = !1)).catch((t => { e = t; })); n;) { if (e) throw e; await u(); } return f }
    
        async function song(output, setBPM, TrackerPattern, createTrack, playFromHere, loopHere, pitchbend, controlchange, waitForBeat, startRecording, stopRecording, startVideo, stopVideo, definePartStart, definePartEnd, mute, solo, addInstrument, addAudio, addVideo, addImage, note, c0, cs0, d0, ds0, e0, f0, fs0, g0, gs0, a0, as0, b0, c1, cs1, d1, ds1, e1, f1, fs1, g1, gs1, a1, as1, b1, c2, cs2, d2, ds2, e2, f2, fs2, g2, gs2, a2, as2, b2, c3, cs3, d3, ds3, e3, f3, fs3, g3, gs3, a3, as3, b3, c4, cs4, d4, ds4, e4, f4, fs4, g4, gs4, a4, as4, b4, c5, cs5, d5, ds5, e5, f5, fs5, g5, gs5, a5, as5, b5, c6, cs6, d6, ds6, e6, f6, fs6, g6, gs6, a6, as6, b6, c7, cs7, d7, ds7, e7, f7, fs7, g7, gs7, a7, as7, b7, c8, cs8, d8, ds8, e8, f8, fs8, g8, gs8, a8, as8, b8, c9, cs9, d9, ds9, e9, f9, fs9, g9, gs9, a9, as9, b9, c10, cs10, d10, ds10, e10, f10, fs10, g10) {
            ${jsmusic}
        }
    
        (async function () {
            const eventlist = await j(song);
            env.value_return(JSON.stringify(eventlist));
        })();
    }());    
    `;
}